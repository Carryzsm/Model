1.谈谈对原型的理解
在js当中是有原型的，有两个，一个是prototype是显示原型，是对象中得一个属性，其本身也是一个对象，属于浏览器的标准属性给开发者使用的，在函数中存在；还有另外一个是__proto__是隐式原型也是一个对象，默认指向的是隐式原型所在的实例对象，是对应的构造函数中的显示原型，是浏览器的非标准属性，给浏览器使用的，在实例对象中存在，隐式原型是在new或者是在创建实例对象中生成，显示原型实在创建函数时产生的，所以说函数也是实例对象，里面有显示原型 和隐式原型。原型的作用之一：为了实现数据共享，节省内存空间，另外一个作用是为了实现继承，其实也是为了实现数据共享。
继承的方式1.为了实现改变原型执行，借用构造函数实现继承（call  apply），还有拷贝继承（浅拷贝和深拷贝（只有引用类型才有），es6中有extend-super）。原型中还有原型链（原型链指的是一种关系：隐式原型和显示原型的关系，隐式原型和隐式原型的关系:其作用是为了查找属性或者方法）。

原型的应用：（在我之前做过的xx项目xxx功能，为了实现xxx组件和xxx组件的通信，使用了全局事件总线，原理是在vue的原型对象上挂载一个属性和main.js中的new vue是继承关系，所以可以直接访问Vue原型对象上的这个属性，也就意味着所有组件可以使用$on和$emit，这样就可以实现通信）

2.谈谈对执行上下文的理解？
其实就是代码区的执行环境：分为全局执行上下文和函数执行上下文（局部执行上下文），代码将要执行之前，先出现全局执行上下文，然后进行内部预解析，内部设置this指向window，收集变量声明，代码继续往后执行，若解析到函数时会产生函数执行上下文（---方式同上），当函数执行结束后，掉用栈中的执行上下文先销毁，局部上下文销毁后全部上下文销毁

3.谈谈你对闭包的理解？
闭包指的是：闭包是函数及其捆绑的周边环境状态的引用的组合，函数之间有嵌套关系，内部函数用到了外部函数 的局部变量，外部函数调用，此时形成闭包。当内部函数对象创建或者是执行内部函数定义的时候 闭包产生了，通过浏览器的调试工具查看发现closure（闭包）存储在函数内部中的scopes数组中发 现闭包中有隐式原型，所以闭包也是个对象。闭包实际上是用来延长局部变量生命周期的，也就是 缓存局部变量的数据，但是局部变量应该随着函数调用而被销毁，本该销毁释放的数据依然存活， 长时间或数据量大没有被释放，会出现内存被泄露导致内存溢出，这也是闭包的缺点。在xxx项目中 xxx模块中的删除产品操作，删除按钮需要绑定点击事件，及其对应的回调函数，并且需要传入产品 的id回调函数内部需要调用相关的接口函数，并且传入这个id此时就是个闭包。通过观察闭包我发现 如果闭包创建会占用内存，如果长时间不用，内存会一直被占用不是很合理，所以我个人觉得闭包 比较好的创建时机应该是在内部函数对象调用的时候更合理一些，这是我的想法，您有什么不同的 见解请指明。

4.谈谈你对作用域的理解
作用域是变量的使用范围，避免变量被污染，分为全局和局部作用域和块级作用域（es6中let，const声明变量所在的区，比如if的大括号、循环的大括号）
在代码书写完毕后作用域就已经确定了，所以作用域是静态的，作用域中的变量在使用时候优先在变量的作用域内查找，如果找不到会逐层的向外层查找，也就是沿着作用域链查找，作用域链使用的是scpoes数组进行存储。明确全局作用域、局部作用域、块级作用域中变量得使用范围，let，const声明得变量是否有提升，以及是否有使用

5.js单线程异步编程语言？
首先js是一门单线程编程语言，这是由他的作用决定的，所以js中的代码应该都是同步执行的，但是从实际的情况来看，js当中的代码时可以异步操作的，原因是js当中有轮询机制，其本质是因为浏览器中有辅助它单线程异步执行的分线程管理模块，也就是代码从上到下执行的时候也就是同步执行的过程中遇到了异步操作对应的回调函数，比如定时器、Ajax、Dom事件，promise 、mutation observe事件，会把这些放到对应的队列中，代码继续执行，promise的回调、multation 会放到代执行的微队列中，其他的回调也会放到待执行的宏队列中，然后初始化同步代码执行后，先把微队列中的代码执行完毕，然后渲染界面，再执行宏队列当中的第一个宏任务，然后轮询。

6.谈谈你对数据代理的理解？
首先vue当中是有数据代理的，vm实例是代理者data是被代理者，通过vm可以直接访问data中的属性，进行属性值的设置和修改操作，实现的流程无非就是new MVVM或者new vue时传入一个配置对象，内部保存配置对象及data进行数据触发操作，然后遍历data数据中所有的属性，调用proxyData方法进行数据代理的实现，该方法内部通过Object.defineproperty为vm实例添加data中的每个属性，并且重写get和set方法，数据代理完毕。

7. 谈谈你对模板解析的理解？
      首先vue或者MVVM中是有模板解析的，在数据劫持后开始进行模板解析，先创建编译实例对象传入选择器和vm实例对象，内部根据选择器获取模板容器，模板容器如果存在才开始进行模板解析，然后把模板容器中所有的节点剪切到创建好的文档碎片对象中，调用init方法开始进行模板解析，整个解析过程是在文档碎片对象中进行的，文档碎片对象在内存中，所以整个解析过程实在内存中完成的，最后会把解析好的文档碎片重新放到模板容器中。init方法内部调用的是complieElement方法，并传入文档碎片对象，该方法内部把文档碎片对象中所有的节点进行了遍历，同时采用的是深度递归的方式，先判断节点是不是标签：
       如果不是就判断节点是不是文本并且是否符合插值的正则，然后提取出插值的文本节点和插值中的表达式调用的相关的方法，该方法内部调用complieUtil中的text方法，内部调用的是bind方法传入插值文本节点和表达式和vm和标识，在bind方法中调用updater中的textUpdata方法，这个方法里边最终使用节点的textContent属性进行表达式值得替换，插值得解析结束。
       如果节点是标签，调用compile方法传入当前得标签节点，该方法内部获取标签中得所有属性，然后进行遍历判断每个属性是不是以v-开头，如果是就说明是指令，然后删掉v-。判断指令是不是on开头，如果不是说明是普通指令，complieUtil对象中得相关方法，内部调用bind方法传入节点、vm、表达式、标识，最后调用updater中相关得方法进行普通指令得解析，  如果此时的指令是事件指令会调用compileUtil对象中得eventHandler方法传入节点vm表达式和去掉v-的事件指令名字，该方法内部在事件名字和回调函数都存在的情况下为当前的节点使用addEventListener方法绑定事件及对应的回调函数并且回调函数内部this的指向是vm，最后无论是普通指令还是事件指令都会通过节点的removeAttribute方法移处标签上指令属性。。如果是v-text指令那就设置标签得textcontent方法，进行赋值解析，如果是v-html指令，那就调用节点得innerHtml属性进行赋值解析，如果是v-class属性最终调用得是className得属性。 

8.数据劫持的理解
数据劫持的目的是为了定义数据的响应式，在数据代理之后模板解析之前通过observe函数调用传入data对象所在空间的地址进行数据的监视和劫持，该函数内部判断传入进来的数据是否是一个对象并且值是有意义的，然后开始创建劫持的实例对象：内部首先保存传入进来的对象数据然后调用方法，方法内部遍历data中的所有属性，调用conver的方法进行数据转换，该方法内部调用了defineReactive方法传入劫持对象的data属性和data中属性的名字和值进行数据响应式的定义，这个方法的内部会创建属性对应的dep对象（id/subs数组）然后再次调用observe函数传入属性值进行深度递归数据劫持操作，最后使用object.defineproperty方法为劫持对象的data也就是外部的data对象添加属性并且重写get、set方法，也就意味着如果外部通过vm操作属性就会进入到数据代理的get或者set方法中同时会自动的进入到劫持的get或者set方法中。
       其实所谓的数据劫持就是定义响应式数据，data对象中有多少个属性就会产生对应多少个dep对象。数据劫持后开始进行模板解析，在模板解析中所有的表达式解析的过程中会调用bind方法该方法中会创建表达式对应的watcher实例对象，也就是模板中有多少个表达式就会创建多少个watcher对象，创建watcher对象的时候会传入vm和表达式及更新界面的回调函数，内部会先进行这三个内容的存储然后获取三个表达式的值，这个过程中会先跳入到数据代理的get方法中因为数据被劫持过所以会跳入到数据劫持的get方法中，先判断表达式对应的watcher是否存在，如果存在调用watcher对象的addDep方法，方法内部会判断watcher对象的depIds中是否有传入进来的dep的id，如果没有就把watcher对象添加到dep对象的subs数组中，把dep的id作为键dep最为值，以键值对的方式添加到watcher对  象的depIds中，至此建立了dep对象和watch对象的关系，dep对象和watcher对象的关系一共有四种，如下：
一对一关系：指的是一个dep对象对应一个watcher对象；
一对多的关系：一个dep对象对应多个watcher对象的关系；
多对一：多个dep对象对应一个watcher；
多对多的关系：多个dep对象对应多个watcher；
当关系建立后，界面中如果对data中数据进行修改就会自动的进入到数据代理的方法中，因数据劫持过所以会进入数据劫持的set方法中，该方法内部先判断新旧值得变化，然后调用属性对应得dep对象中得notify方法，方法内部会遍历dep对象中得subs数组也就是找到dep对象对应得所有得watcher对象调用run方法，先进行更新后数据的获取然后判断新旧值得变化，并重新创建新得关系，调用实例化watcher得时候，对界面进行重新渲染得操作，以上就是数据响应式得原理。

8.谈谈数据响应式得理解：
      首先内部进行数据劫持操作，根据data中属性得个数产生对应个数的dep对象，然后进行模板解析，根据模板中表达式的数量产生对应的watcher对象，同时建立dep对象和watcher对象的关系。dep对应着watcher，watcher对应着dep。把dep加入到watcher中，前者是为了加载数据，dep对应着watcher，后者是为了解除两者的关系，具体如何进行数据劫持可以参考数据劫持的流程，如何建立关系可以参考watcher建立的流程。

9.双向数据绑定v-model实现的流程
       在模板解析的时候获取文本框节点并遍历里面的属性找到v-model指令属于普通指令，调用compileUtil对象的model方法内部通过bind方法调用updater中方法为文本框的文本属性进行赋值同时建立dep和watcher对象的关系，最终使用addEventListner方法绑定input和对应的函数，当文本框的内容发生改遍就会触发input事件，通过事件源对象获取改变后的新值然后修改data中的属性值会触发数据代理和数据劫持中的set方法，内部通过修改属性对应的dep对象调用notify方法通知关联的watcher调用run方法对界面进行渲染。
---------------------------------------------------------------------
10.promise的理解
       首先promise是es6中新增的更好的异步编程解决方案，原生ajax可以实现异步操作属于宏任务，如果内部进行dom操作会增加页面的渲染次数效率比较低，原生Ajax发送请求的时候指定回调函数的时机比较固定而且有回调地狱的问题，而promsie属于微任务，微任务中如果进行dom操作界面渲染的次数比较少效率比较高同时promise指定回调的时机更加灵活可以在请求前请求后请求结束后指定回调函数，同时减少了回调地狱的嵌套层数属于纯回调的方式，但是没有真正的解决回调地狱，promsie中有三种状态分别是pending、fulfilled、rejected，两种变化效果：从初始到成功，从初始到失败而且是不可逆的，promise中有链式编程通过.then方法来实现，.then方法返回的promise结果由.then方法执行的回调函数的执行结果来决定，如果执行出错或者返回一个失败的promise就会导致promise是失败的，如果返回一个成功的promise或者一个非promise的任务值会导致promise是成功的，如果返回的promise中传入了一个空回调也就是pending状态，此时会中断promise链，promise中有两个方法常用：一个是all一个是race，前者是所有的promise都成功其结果就是成功的，后者是第一个成功的就是成功的。asyn、await是generator的语法糖可以简化generator写法，真正的解决了回调地狱。有async可以返回一个promise，可以没有await，有await必须有async。


11.谈谈ES6新特性的理解：
     首先es6是2015年发布的，全称是ECMA2015简称es6到2023年达到了es14，es6以后平均每年新增一个版本，es6中新增了一些特性如：let、const用来声明变量和常量的也就也为着出现了块级作用域，let和const声明的常量是有提升的，根据tc39.es也就是ecma官方英文文档明确指出虽然提升但是不能使用，还增加了解构赋值、扩展运算符和形参默认值和class用来定义类的可以使用extends和super进行继承，以及模块导入导出（import ），还有symbol数据类型用来定义唯一的数据标识，数组对象字符串都增加了扩展的相关方法也增加了iterator接口机制和generator函数用来实现异步操作但是使用起来比较麻烦，所以es6中增加了promise和async await用来简化promise的写法，还增加了set和map容器：前者用来存储唯一的多个数据，后者以键值对的方式存储数据，还增加了proxy对象可以用来实现数据的代理和响应式，还增加了箭头函数以及模板字符串。

12.谈谈对事件冒泡和事件委托的理解：
       所谓的事件冒泡指的是标签或组件之间有嵌套关系，都注册过或绑定了相同或类似的事件，里面元素或元素的事件触发了外部的元素的或组件的事件会自动的触发。事件的理解：指的是视图层到逻辑层的一种通信方式。事件委托基于事件冒泡，父级元素中有很多子集元素，只需要给父级元素绑定事件，通过子集元素就可以触发外部元素的事件这种方式可以减少事件绑定的事件从n个变成一个，减少内存的使用并提高效率，即使内部动态添加元素事件也能有对应的响应，其应用：比如我之前做过的xxx项目，里面的2或3级分类的展示及跳转操作利用事件委派的方式减少事件的绑定次数，提升效率，做出项目优化。

13.谈谈你对Ajax的理解：
       Ajax全称是Async JavaScript and XML ，ajax可以在页面不刷新的情况下，发送请求获取数据实现页面的局部刷新或者渲染，原生ajax封装需要new  XMLHttpRequest()创建对象，调用open方法通过设置监听事件，onreadystatechange判断响应状态码，最终通过send来发送请求，Ajax请求是一种比较特殊的http请求，对于服务器而言，Ajax请求和一般的http请求没区别，在浏览器端如果使XHR/fetch发出的请求才是ajax请求，其他方式都是非Ajax请求，一般的请求浏览器会直接显示响应体数据也就是页面刷新或者页面跳转，而Ajax请求浏览器不会对页面进行整体刷新，只是调用监听的函数，传入相应的响应式数据，ajax操作属于宏任务。

14.谈谈ts的理解：
ts始于js终于js，js是一门基于对象的语言而ts是一门面向对象的编程语言，js是弱类型语言而ts是一门强类型语言，js中声明变量使用var let const而ts中也可以用但是变量在声明的时候需要先指定数据类型，ts中是可以使用es6，ts中常见的数据类型有string 、number 、Boolean  、null 、undefined  、enum（在数据值个数固定的情况下或者供用户开发者选择数据值的情况下可以使用枚举）、 array、 tuple（元组：可以设定数组中存储的数据的类型不一致）、 any（存时容易取时难）、 void、 object 、联合类型（|），除了这些基础的数据类型外，ts中还有class类：内部的成员都是有默认的访问修饰符是public代表的是任何地方都可以访问类中的成员，如果使用private修饰类中的成员那么这些成员只能在本类中使用，如果成员前使用protected那么表示该成员可以在本类或子类中使用，ts中类和类之间可以有继承关系使用extends实现，被继承的类叫做基类，类中的属性成员可以使用readonly进行修饰表示只读，类中的成员的前面也可以使用static修饰，表示的是静态成员给类名使用的，类中属性成员可以单独的设置get和set方法叫存取器，其可以对属性值进行具体的读取和设置操作。ts中如果在一个类也就是class前面使用abstract进行修饰，这个类叫做抽象类，抽象类是不能实例化的，抽象类中的成员可以是实例成员，抽象方法必须在抽象类中（方法名前使用abstract修饰），且抽象方法不能有具体的实现，抽象类存在的意义就是为子类服务的，如果子类也是抽象类，那么父类中的抽象成员是可以不进行实现的。ts中的函数可以有重载也可以有重写，但是js中不能有重载，函数中的参数有可选参数和默认参数，如果这个参数是可选参数建议放在参数列表的最后。ts中的接口表示的是一种规范或者是一种能力，可以用来定义对象的类型限定对象中有哪些属性成员换言之可以作为对象的数据类型来使用，由此也可以认为接口是一种约束，接口也可以作为函数的类型使用，规范函数的定义限定函数的参数和返回值，接口也可以作为类的选择器使用，类和接口之间也可以通过implements来实现，也就意味着接口在定义的时候里面的方法是没有实现的，一旦让某个类实现了这个接口，这个类就需要把接口中未实现的方法进行实现 ，也可以理解为这个类有了接口这种能力，一个类可以实现多个接口，接口和接口之间使用的extends来继承，接口可以继承多个接口。

15.interface和type的区别：
      首先interface用来定义对象的属性，也可以用来描述函数的类型。type可以用来定义任何类型，包括基本类型、联合类型、元组类型、函数类型等。其次扩展性不同，interfere使用extends进行扩展，type使用交叉类型进行合并。

16.谈谈你对ts泛型的理解：
       可以在定义函数、接口或者类的时候先不去指定具体的类型，而是在使用的时候再去指定类型，是一种特性也是一种约束，比如函数在声明的时候不确定参数的类型及返回值的类型，此时可以使用泛型来定义这个函数，这种函数叫泛型函数，在调用的时候传入类型那么对应得参数和返回值得类型就已经明确了。接口在定义得时候也可以使用泛型此时叫泛型接口，也有泛型类，也有泛型约束都是在定义得时候通过尖括号得写法来指定不具体得类型。如K、T、V，在使用得时候再去明确具体的类型就是一种约束，之前再vue3框架做得xxx项目里面api接口函数定义得时候用到了泛型得axios，父子组件通信得时候，子级组件接受父级组件传递的数据，使用defineProps的方式。

17.http协议得理解
它是一个超文本传输协议，也就是浏览器与服务端通信的连接协议：

http协议是无状态的，对于事物的处理没有记忆能力，服务器不知道客户端什么状态，也就是说这次打开的页面和上次打开的页面没有联系，http协议是基于tcp协议和ip协议之上的，http属于应用层协议，tcp属于传输层协议，网络层使用的是ip协议

协议当中通信的内容称之为报文，浏览器发给服务器叫做请求报文，服务器返回给浏览器端叫做响应报文，报文分为报文首行，报文头部，报文空行、报文体，请求报文分为首行、请求头、空行、请求体，响应报文分为首行、头部，空行，响应体，首行中包含请求方式、请求地址、协议名及版本号，头部中有connection：keep-alive叫长链接，content-type叫请求体参数类型，user-agent叫用户代理，referer叫请求来源地址，cookie等，空行是用来隔离头和请求体，access-control-allow-origin表示的是允许跨域，Cache-Control叫强制缓存控制，Etag / Last-Modifined叫协商缓存控制。

18.长链接和短链接理解
无论是长链接还是短链接指的都是客户端与服务端进行http操作的一种连接方式，http协议1.0中默认使用的是短链接也就是浏览器和服务器进行http操作的时候建立一次连接，操作一些任务，任务结束后就中断连接，如果再有请求操作重新建立连接进行数据传输，完毕后再次关闭，也就是多次请求多次建立连接多次关闭连接。http1.1中默认使用长链接需要设置connection：keep-alive表示的是长链接，也就是打开一个页面后浏览器端和服务器端用于传输http数据的时候tcp的连接不会关闭，这个连接会一直保持，但是如果长时间保持，对服务器而言也是有一定的压力，而且连接不断开，客户端容易出现恶意连接托跨服务器（恶意：），所以服务端一般会采用一些策略对长链接设置一个保持的时间，超过这个时间就会关闭这个连接，http协议的长链接和短链接实际上是tcp的长链接和短链接，短链接的操作步骤：建立连接、数据传输、关闭连接（重复），长链接的操作步骤：建立连接，数据传输，保持连接、数据传输、关闭连接（重复），长链接的优点：省去较多的tcp建立和关闭的操作，减少浪费节约时间，频繁的请求资源适合使用长链接，需要服务端控制最大的连接数及保持时间，短链接的有点：服务端管理简单，存在的连接都是由价值的，不需要额外的控制手段，但是tcp的建立和关闭会浪费很多的时间和带宽，如果客户量比较大请求又频繁建议使用短链接。

19. http1.1和http2.0的区别：
传输数据的方式不一样，http1.1采用的是文本和二进制的方式，http2采用的二进制的形式，也就是头部信息和数据体都是二进制，协议2.0中有多路复用，仍然复用http协议，浏览器和服务器都可以同时发送多个请求或响应而且不用按照顺序依次发送，协议1.1采用的是若干个请求排队串行单线程处理，前面的请求完事后后面的请求才可以执行，一旦某个请求超时就会阻塞后面的请求，也叫线头阻塞，协议2中采用了头部压缩机制，协议1.1中没有状态每次请求需要携带所有信息，请求的很多字段都是重复的比如cookie和user-agent一样的内容每次都要携带，浪费带宽影响速度，协议2中使用gcip或者compress压缩后再发送，也就是浏览器和服务器端维护一张头部的信息表，所有的字段存入这个信息表，生成一个索引，发送的请求中只发送索引号，速度明显会提升，协议2中允许服务器没有经过请求主动向客户端发送资源也叫服务器推送，可以减少延迟时间，推送的资源是静态的，可以实现即时通信操作。

20. http和https的区别：
http协议是超文本传输协议信息是明文传输，https是具有安全性的SSL（对称加密）加密传输协议，两者采用了不同的连接方式，默认端口不一样，前者是80后者是443，前者无状态后者属于加密传输，需要身份认证，比http更加安全，另外https协议需要申请CA证书，免费的很少需要花钱。

21. 谈谈跨域：
所谓的跨域指的是同源策略中协议、域名、端口三者相同，如果有一个不一样就会出现跨域错误，普通的http协议请求时不存在跨域的，一般情况下发送ajax的时候浏览器要求当前页面和服务器必须同源目的是为了安全，服务器和服务器之间是没有跨域的，页面中加载图片线上的js或者css都不受同源策略的限制，解决跨域常见的策略有三种：JSONP、CORS、 proxy：

      JSONP原理利用的是script标签发送请求不受限制，需要在前台script的src属性中设置目标地址及回调函数，后台需要处理请求产生返回的数据，读取传入过来的回调函数包括里面的请求参数返回执行函数的js代码，这种方式只能处理get请求，每个请求在后台都要做处理很麻烦。
      CORS的原理：后台中返回浏览器在某个域上发送的跨域请求的相关响应头需要配置跨域的地址、跨域的请求方式、跨域的请求字段、请求缓存的时间、cookie等相关信息，前台不需要做任何的处理，后台处理也是比较麻烦的。（CORS的原理是通过在HTTP请求头中添加一些特定的字段，来告诉服务器是否允许跨域访问。当浏览器发起跨域请求时，会先发送一个预检请求（OPTIONS请求），询问服务器是否允许跨域访问。如果服务器允许跨域访问，则在响应头中添加一些特定的字段，告诉浏览器可以访问该资源。）
      proxy：只需要在对应的脚手架中设置webpack的配置项，比如处理地址的开头标识、目标服务器地址、是否可跨域、路径是否可重写即可。
      代理可以分为正向代理和反向代理，正向代理代理的是客户端，反向代理代理的是服务端，可以利用nginx进行反向代理实现项目上线。

22.谈谈axios的理解：
      首先它是一个函数，可以直接传入地址发送请求，也可以传入一个配置对象设置请求方式、地址、params参数及请求体参数，也可以直接通过axios调用方法发送请求：get、post、put、delete等，可以用来实现前后端交互，内部封装了ajax，react或者vue中都可以使用ajax进行异步操作发送请求（低版本的vue框架之前使用的vue-resource，原生的也可以使用fetch，想在服务端使用也可以使用flyio，小程序中使用的是wx.request），通常情况下要要对axios进行二次封装，封装进度条的显示效果、根路径、超时时间、请求拦截器和响应拦截器，请求拦截器中一般会在请求头嵌入token、临时用户id、cookie，响应拦截器中成功的回调内部返回的是响应的数据，失败的回调中对错误信息进行判断和处理（比如：判断token是否过期，然后进行退出登录操作或者是重置用户信息操作通过路由跳转到登录页并且设置提示信息，如果需要外部处理错误信息需要返回一个失败的promise，如果不想把错误信息传递下去可以中断promise），axios中有四个任务分别是：请求拦截器中的回调、发送请求的回调、响应拦截器中成功或失败的回调以及请求完毕后的成功或失败的回调，内部使用的是promise.then链式调用的方式串联这四个任务，所以请求拦截器中返回的config对象实际上应该是一个promise，通过promise.then串联请求的回调函数，内部仍然返回一个promise对象，再用.then串联响应拦截器中的成功或失败的回调，最后再.then串联请求请求成功或失败的回调。

23. 输入url地址到渲染页面的整个过程：
       首先要进行url的判断，也就是解析url是否合法有效然后进行缓存判断，之后开始dns解析也就是将域名解析成ip地址，先进行浏览器的dns缓存然后是计算机的dns缓存、路由器的dns缓存、网络运营商的dns缓存（要有一个递归查询的过程），之后开启http连接的三次握手，目的是为了建立连接，之后开始发送请求（把请求报文发送过去）返回响应（将响应报文发送回来）解析并渲染页面（遇到HTML通过对应解析器解析成Dom树，遇到css调用css解析器解析成cssom树，遇到js先初始化js同步代码，再执行微队列中的任务，如果遇到要修改的元素重新调用HTML解析器解析成dom树，如果遇到样式修改调用解析器解析更新cssdom树，然后将dom和cssom进行渲染操作然后设置内容布局及渲染操作，然后执行宏队列中的第一个任务），最后断开连接也就是tcp四次挥手，断开请求和响应连接各两次

24.谈谈wbsocket的理解：
websocket是h5新增的  进行全双工通信的应用层协议基于tcp传输层协议，浏览器和服务器完成一次握手后两者之间的连接是持久性的可以进行双向数据传输，之前浏览器想要获取服务器的数据，要么使用ajax的轮询，要么采用长时间占用连接的方式给服务器带来压力，websocket出现后可以解决同步延迟问题，并且进行双向通信实时性更强，可以发送文本也可以发送二进制，数据属于轻量级性能高、通信高效、没有同源限制、可以与任意服务器进行通信与http协议具有良好的兼容性，不易被屏蔽，默认端口是80和443，协议的标识符是ws，如果加密是wss，通过send方法可以发送消息给websocket服务器，通过message方法可以接收消息，应用场景有：弹幕、媒体标签（音视频数据传输）、即时聊天、协同编辑、位置数据更新、体育实况更新、股票基金报价更新、大屏展示更新、实时传递数据。

25. 谈谈webpack
       首先它是一个静态模块打包工具，可以将静态模块编译打包、输出成一个或多个文件，文件中主要有五个核心：分别是entry（入口：表示webpack从哪个文件开始打包），output（输出：webpack编译打包后的文件输出到哪里，output中的path建议使用绝对路径，输出的文件名字最好是使用根据内容生成哈希值的方式也就是内容变化哈希值就变化），loader（加载：webpack只能识别js或json文件，其他类型的文件需要通过loader转化成有效的模块才能识别），plugin（插件：可以进行打包的优化：资源管理、注入环境变量的模式、可以选择生产环境或者开发环境或者是none中的一个），mode（模式：不同模式会加载不同的配置，），常见的loader有：
 
1. 处理样式资源：
● style-loader 动态创建一个 Style 标签，里面放置 Webpack 中 CSS 模块内容
● css-loader 负责将 CSS 文件编译成 Webpack 能识别的模块
● less-loader 将 Less 文件编译成 CSS 文件
● sass-loader 将 Sass 文件编译成 CSS 文件
● stylus-loader 将 Stylus 文件编译成 CSS 文件
● postcss-loader 根据要求增加 CSS 的前缀(css 代码兼容性处理)

2. 处理 js 资源
● babel-loader 将 ES6 转化为 ES5(js 代码兼容性处理)
● eslint-loader 过去用来进行 js 代码语法检查，最新 Webpack5 改用插件实现：eslint-webpack-plugin

3. 加载其他资源
● file-loader 过去用来转化图片、字体图标等资源，现在 Webpack5 内置了
● url-loader 过去用来转化图片等资源，现在 Webpack5 内置了
● vue-loader 用来编译 Vue 单文件组件

常见的plugin：
1. html-webpack-plugin 简化创建 HTML 文件
2. eslint-webpack-plugin 用来进行 js 代码语法检查
3. terser-webpack-plugin 压缩 js 代码
4. mini-css-extract-plugin 提取 CSS 成单独文件
5. css-minimizer-webpack-plugin 压缩 CSS 代码

webpack优化相关的：（挑两个）
1.提升开发体验

● 使用 Source Map 让开发或上线时代码报错能有更加准确的错误提示。

2. 提升 webpack 提升打包构建速度

● 使用 HotModuleReplacement 让开发时只重新编译打包更新变化了的代码，不变的代码使用缓存，从而使更新速度更快。
● 使用 OneOf 让资源文件一旦被某个 loader 处理了，就不会继续遍历了，打包速度更快。
● 使用 Include/Exclude 排除或只检测某些文件，处理的文件更少，速度更快。
● 使用 Cache 对 eslint 和 babel 处理的结果进行缓存，让第二次打包速度更快。
● 使用 Thead 多进程处理 eslint 和 babel 任务，速度更快。（需要注意的是，进程启动通信都有开销的，要在比较多代码处理时使用才有效果）

3. 减少代码体积

● 使用 Tree Shaking 剔除了没有使用的多余代码，让代码体积更小。
● 使用 @babel/plugin-transform-runtime 插件对 babel 进行处理，让辅助代码从中引入，而不是每个文件都生成辅助代码，从而体积更小。
● 使用 Image Minimizer 对项目中图片进行压缩，体积更小，请求速度更快。（需要注意的是，如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。）

4. 优化代码运行性能

● 使用 Code Split 对代码进行分割成多个 js 文件，从而使单个文件体积更小，并行加载 js 速度更快。并通过 import 动态导入语法进行按需加载，从而达到需要使用时才加载该资源，不用时不加载资源。
● 使用 Preload / Prefetch 对代码进行提前加载，等未来需要使用时就能直接使用，从而用户体验更好。
● 使用 Network Cache 能对输出资源文件进行更好的命名，将来好做缓存，从而用户体验更好。
● 使用 Core-js 对 js 进行兼容性处理，让我们代码能运行在低版本浏览器。
● 使用 PWA 能让代码离线也能访问，从而提升用户体验。

25. vite和webpack的比较：
首先第一点底层原理不一样，底层使用的是go语言是纳秒级别的，而webpack底层使用的C是毫秒级计算的，所以vite比webpack打包速度快10-100倍。启动方式不同：webpack是编译打包再交给服务器进行渲染，要分析各个模块之间的依赖然后再进行打包，如果模块越多关系越复杂处理的就越慢，更新就越来越慢。而vite启动方式：启动服务请求模块时按需动态编译显示采用的懒加载方式，启动时不需要打包，不需要分析模块之间关系也不需要进行编译，只有再浏览器请求某个模块时根据内容再进行编译，所以缩短了编译时间，项目越复杂模块越多的情况下优先使用vite，但是也有缺点vite的生态不及webpack，加载器插件不够丰富，生产环境对于css和代码分割不够友好，vite的优势是在开发阶段，首屏性能不及webpack，webpack中浏览器发送请求服务端直接把打包后的首屏内容发送给浏览器没有性能问题，而vite在首屏方面需要再做一些额外的事情，没有对源文件做合并捆绑操作，会产生大量的http请求，dev server 运行期间对源文件做 resolve、load、transform、parse 操作，预构建、二次构建会阻塞构建请求，直到构建完成为止。

26.谈谈Vue的理解：
首先vue是一个渐进式的框架，所谓的渐进式指的是本身实现的功能是有限的，相关的插件有很多，安装使用后可以实现更多的功能，在vue中是有数据代理的以及数据劫持和模板解析，（diff算法），

（1）vue中常见的全局api有：
vue.extend：创建一个子类继承vue构造器，参数是一个组件对象。
vue.nextTick：在下次dom更新循环之后，执行延迟回调，它可以获取更新后最新的dom。
vue.delete：可以用来移除响应式对像的属性
vue.set：可以向响应式对象中添加一个属性，也是响应式的且触发视图更新；
vue.directive：用来定义全局指令
vue.filter：可以用来定义过滤器，通常可以实现日期或事件的格式化操作。
vue.component：可以用来定义全局组件，其返回值是该组件实例对应的构造器。
vue.use：可以用来注册和使用插件，内部实现原理是调用install方法把对象挂载到vue原型上。
vue.compile：可以传入模板字符串，最终编译成render函数。

（2）在vue中常见的组件选项有：
data：（用来存储组件的数据状态）在组件中data是一个函数不能是一个对象，原因是：组件多次复用的时候要保证data中的数据是响应式的，而且不能出现冲突。
computed：计算属性，一个数据发生变化其关联数据也发生变化，计算属性是有缓存的是响应式的。
methods：是一个对象，里面用来定义方法
watch：当一个数据发生变化需要做什么操作时使用，内部由深度监视和默认执行操作的设置（deep和immediate）（立即执行）。
directives：用来在组件内部定义多个局部的自定义指令的方法（在组件内定义自定义指令）。
filters：用来定义组件内部的过滤器方法。
components：用来注册组件
name：组件的名字。如果是递归组件必须要有name属性。

（3）vue中常用的指令：
v-text：相当于插值语法，设置标签中间的文本内容，本质是textContent（标准属性）或者innerText（没有使用）。
v-html：用来设置标签中间的html内容，其原理使用的是innerHtml
v-for：（用来遍历对象或者数组，内部需要使用到in也可以使用of
v-if  /v-else/v-else-if/v-show：用来控制组件或标签显示隐藏， v-show控制display  ， v-if等控制dom创建或销毁，v-                                                 show效率更高，vue2或者vue3中都不建议v-if和v-for同时使用  ，vue2中v-for优先级高                                                           于v-if，vue3中相反）
v-bind：强制数据绑定指令（单向数据绑定），多数情况下用在组件或普通标签上。v-bind中可以传入对象，键是属性，值              是对应的表达式。
v-model：双向数据绑定指令，多数情况下用在组件或者表单标签上。
v-on：用来实现组件或标签的事件绑定操作。v-on后面可以绑定一个对象，键是事件名字值是回调函数。

（4）vue中有几个特殊的属性
key：需要传入标识，如果没有增删改操作只是遍历显示可以使用索引作为key值
ref：用来获取组件对象或者dom对象
is：需要配合内置组件component，进行动态组件的创建和使用。
slot/scop/slot-scope：用来操作插槽，（已经被废弃，可以使用）

（5）vue中有内置组件
component：用来定义动态组件
transition：用来实现过度效果
keep-alive：缓存组件
slot：插槽分为普通插槽，具名插槽，作用域插槽

（6）谈谈Vue中的生命周期钩子
vue中是有生命周期的，所谓的生命周期的，指vue组件从创建到销毁的一个过程，这个过程中会牵扯到11个钩子，在不同的时机被自动的调用。分别是：
beforeCreate：表示的是实例对象已经创建，数据还没有初始化，是数据初始化之前的一个钩子，这里是不能使用data、                              methods。几乎不用。
created：数据初始化完毕以后执行的钩子，这里可以使用data、methods，如果涉及到页面首屏数据展示，这里可以发送                    ajax请求进行异步操作，此时数据代理已经完事，开始进行数据劫持操作（我知道数据代理和数据劫持的原理）
beforeMount：挂载之前，也可以叫页面渲染之前的钩子，此时页面呈现得是数据没有更新之前的假页面，也就是内部已经                           进行了模板解析。
mounted：挂载后得生命周期钩子，此时界面已经渲染完毕，也就也为着模板解析已经结束
beforeUpdate：如果界面中有响应式数据改变得情况，beforeUpdata生命钩子会被调用，此时data中得数据是最新的，数                         据对应得dep会通知对应得watcher对象进行页面得更新操作。
updated：在界面更新完毕后会被调用
activated：激活。
deactivated：失活。
beforeDestroy：表示的是组件卸载前的生命周期钩子，销毁定时器、事件解绑、取消消息订阅等都在这个钩子里进行。
destroyed：组件销毁后，调用的生命周期钩子，比如：某组件中用到了一次性的缓存信息，并且组件切换后缓存信息不需要了，此时可以在这个钩子中清空缓存数据，如：添加购物车界面成功跳转后，销毁页面。
errorCaptured：抓捕子集组件报错的钩子。

（7）如果有父子组件：父三子一（先执行父组件的beforeCreate、created、beforeMount然后执行子集组件的beforeCreate、created、beforeMount、mounted，最后执行父级组件的mounted），如果涉及到父子组件共用的数据被修改，钩子的执行顺序是：先执行父组件的beforeUpdata再执行子组件的beforeUpdate、updated，最后执行父组件的updated。
如果进行销毁操作：先执行父组建的beforeDestroy再执行子集组件的beforeDestroy、destroyed，最后执行父组件的destroyed。如果组件被缓存了，组件进行切换操作，先执行子级组件的deactivated再执行父级组件的deactivated，如果是激活操作，先执行子级组建的activated再执行父组件的activated。

（8）vue2的生命周期钩子和vue3的不同，vue3的生命周期钩子如下：
onBeforeMount()
onMounted()
onBeforeUpdate()
onUpdated()
onBeforeUnmount()
onUnmounted()
onErrorCaptured()
onActivated()
onDeactivated()

onRenderTracked()
onRenderTriggered()
onServerPrefetch()

27.谈谈vue2中组的件通信
vue中是有组件通信的，组件指的是具有特定功能特定效果功能的集合，包含html/css/js，组件其实也是对象，组件和组件的关系有：父子组件、兄弟关系、任意关系。组件通信指的是不同关系的组件进行数据的传递，常见的组件通信有：

1）props：用来实现父子组件通信
2）自定义事件：用来实现父子组件通信 
3）事件总线：任意组件通信，原理是在vue的原型上绑定一个vue的实例，各个组件的实例对象与他是继承关系，一般不用。（原型对象上可以绑定一个$api存储所有的接口函数）
4）插槽：分为普通、具名、作用域插槽，用来占位可以实现父子、子父组件通信。
5）ref：用户来获取dom对象或者是组件对象，然后调用组件中属性或方法实现父子组件的通信。
6）v-model：本质是input和value属性 ，用来实现父子组件的通信.
7）.sync:本质是updata事件+动态属性可以实现父子组件通信
8）$attrs和$listeners：可以实现父子组件通信，在封装复用率比较高的组件中会用到，可以称之为高级复用组件。
9）$parent和$children：可以实现父子组件的通信
10）vuex：集中式状态管理数据，可以实现任意组件的通信，里面有五个对象（state：包含了多个状态数据的对象。mutations：包含了多个直接修改状态数据的方法的对象。actions：包含了多个间接修改数据的方法的对象。getters：包含了多个状态数据的计算属性的get方法的对象。modules:包含了多个子集模块的对象。数据修改方式为组件中分发action，action内部commit 给mutation，mutation内部修改数据，或者组件中直接commit对应的mutation，然后修改数据），总的action和子的action如果同名，先执行总的再执行子的。mutation中可以进行异步操作，但是不推荐。因为vue的调试工具中不能检测到更改的数据，导致页面不能及时更新。vuex中还有几个常用的辅助函数：mapState、mapMutations、mapActions、mapGetters。
11）provide和inject：可以实现直接或间接父子组件通信
12）pubsub：不属于任何框架，独立存在，可以实现任意组件或页面的通信。
13）路由传参和本地缓存也可以实现任意组件的通信。

我的项目中一般情况下会用到3-5中左右，比如：


28.谈谈路由的理解：
       路由指的是一种映射关系，地址和组件的关系（path与component的关系），路由需要通过路由器进行管理，多个路由会形成路由对象组成的数组，每个路由器也是对象，也就意味着浏览器的地址栏中输入地址回车之后可以看到地址对应的组件内容。路由分为hash和history模式，区别在于地址栏中的地址是否带#以及项目上线后history模式的路由如果直接访问某个地址，页面中的JS解析前台路由路径的时候在服务器的根目录下找不到对应的资源，会返回404服务器需要配置try_files $uri $uri/ /index.html$args; ，当404的时候总是返回首页。路由分为路由链接和路由视图，也就是router-link和router-view，前者最后会产生a标签，to属性中的值会存储到href中，页面中点击a标签路由视图会显示对应的路由组件中的内容，这种方式属于声明式路由，也就是不需要书写JS代码就可以实现路由跳转。编程式路由需要通过编写JS代码来实现路由跳转，需要通过路由器对象调用push和replace方法，路由跳转的过程中可以进行参数的传递，有query、params、props以及meta，params方法需要使用：方式占位、props分为布尔、对象、函数模式，？表示参数可有可无。路由也分为一级路由二级路由还有多级路由。
       路由在编程式导航跳转中会出现一个多次重复的bug，原因是路由在升级的过程中，相关的版本当中编程式路由跳转返回的是promise对象，需要我们在push或replace路由跳转中传入成功和失败的回调，或者是调用.then和.catch方法，一个项目中会出现多次的编程式跳转，每次跳转都要传入回调很麻烦，所以通过路由器的原型对象重写push和replace方法，默认传入成功或失败的回调，从根本上解决问题，再有编程式路由的时候就不用那么麻烦了，当然现在的路由版本中没有这个问题。（建议不说）

29.路由守卫（导航守卫）
       是用来控制路由跳转的，分为全局路由守卫，路由独享守卫和组件内的守卫，一共有七个钩子（313形式）：
全局导航守卫分为全局前置守卫（beforeEach）、全局解析守卫（.beforeResolve）、全局后置守卫（afterEach）；路由独享（beforeEnter）；组件内的守卫分为三个也是：前置守卫（beforeRouteEnter）、解析守卫（beforeRouteUpdate）和后置守卫（beforeRouteLeave）。

30.路由的本质
router-link和router-view在路由器安装后都变成了全局组件，router-link最终被编译成a标签，a标签得跳转实际上是通过location对象相关方法，编程式中得push实际上是bom中得history对象中得pushState得调用，编程式路由中得replace方式实际上是bom中得history对象中得replaceState方法的调用，路由跳转时传递得参数可以通过bom中得history对象中state来获取。

31.vue中常见得各种组件
vue中常见得各种组件：普通组件、全局组件（使用vue.component方法进行注册）、路由组件（普通组件进行了路由注册）、动态组件(使用component组件加is属性动态产生得组件)、异步组件（可以通过工厂函数动态编译得组件实现了按需加载，工厂函数内部可以使用template进行模板编写或者时require引入或者是import()得方式引入组件，这些都属于异步组件）、函数组件（需要设置组件内的组件，function为true加render函数可以实现函数组件得定义，无状态无实例无生命周期，所需数据需要父级组件传递）、递归组件（组件内部调用组件自己必须要有name）。

32.    谈谈vue3理解
首先vue3中支持vue2中得大多数特性，更好得支持ts，打包文件变小了，初次渲染速度和更新渲染速度变快了，内存占用率变小了，使用的组合api，vue2中使用的是选项api，vue2中组件内部必须要有根标签，vue3中可以没有根标签，可以使用脚手架vite创建vue3项目，vite也可以创建vue2和react项目。setup函数是组合api中的一个，也是组件中一个新选项，也是入口点，setup方法执行的时机比beforeCreate更早，所以里面是没有组件实例对象的，也就意味着this是undefined不能使用，setup方法返回值是一个对象，对象中的数据可以在模板中直接使用，该方法的参数有两个，参数一是props用来接收父级组件传递过来的数据，第二个是context可以认为是组件中的执行上下文相当于this，可以调用attrs属性，里面包含了没有通过props接收的数据，也可以调用slots获取传入过来的插槽对象，还可以调用emit用来分发自定义事件的函数，不建议在setup中进行异步操作（如果在vue3中使用了vue2语法中的data或者motheds，里面的方法名和setup中定义的数据或者方法名重了，会被setup覆盖，现在会报错。）。vue3中通过ref定义基本类型数据的响应式，通过reactive定义复杂类型的响应式，当然也可以通过ref定义引用类型的响应式，但是内部的数据类型都是proxy类型，reactive定义的响应式数据是代理数据也是深度响应式，vue2中响应式数据的原理使用的是Object.definieProperty方法，重写了get和set方法，缺点：响应式对象通过点语法直接添加属性和数组通过索引添加以及修改数据都不是响应式的，需要调用set方法或者是更新数组的方法才可以实现响应式，vue3中数据代理及响应式使用的是proxy+reflect（reflect.get可以读取目标对象中的属性，免去了重复遍历节约了时间）。

(1)vue3中计算属性和监视：
       vue3中计算属性和监视与vue2中略有不同，vue3中的计算属性也是一个api可以传入一个对象，对象中可以书写get和set方法当读取数据或修改数据时触发，计算属性中也可以传入一个回调代表的是get操作，计算属性的返回值是一个ref类型的数据。vue3中的·监视常用的有两个：watch和watchEffect，watch在使用的时候可以传入三个参数，参数一可以是一个带有返回值的回调也可以是一个ref，还可以是一个响应式的对象，或者可以书写拆包的方式（...运算符拆包后的数据也应该是响应式的），也可以是一个数组，数组中的数据必须是前面方式中的一种。参数二使用来书写逻辑的回调函数。参数三是一个对象，里面可以设置deep、immediate。watchEffect中传入一个回调默认会执行一次。

(2)vue3中组件通信和vue2的区别：
        vue3中没有.sync，组件中如果使用v-model可以书写多个，其本质是updata事件后面跟动态属性，vue3没有$listeners事件，vue3中可以使用mitt插件实现事件总线，但是几乎不用，vue3中推荐使用pinia，pinia中可以使用$patch方法对状态数据进行批量修改，该方法中可以直接传入对象，对象中书写键值对的方式直接修改状态数据，也可以传入一个回调，回调中的参数state在方法内部调用属性进行数据修改，也可以直接通过模块对象调用$state赋值对象内部书写键值对直接替换状态数据的方式来进行修改。vue2是2016年的 vue3是2020年出现的。

(3)vue3生命周期：
        vue2中的生命周期11个vue3 有12个，vue2中干掉了beforeCreate、created，vue3中的生命周期都是api内部传入回调函数，可以重复使用多次，vue3中onBeforeMount和onMounted相当于beforeMount和mounted，onbeforeUpdate和onUpdated相当于vue2的beforeUpdate和 updated ，vue3的onBeforeUnmount()和onUnmounted()相当于vue2的beforeDestroy和destroyed。抓捕子集报错的是onErrorCaptured()。激活和失活：onActivated()和onDeactivated()，还有三个服务器相关的：onRenderTracked()、onRenderTriggered()、onServerPrefetch()

       vue3中所有的生命周期钩子要比vue2中对应生命周期钩子早一步（比如挂载前、挂载后）

(4)vue2中也是可以使用pinia，需要安装一个组合式api：$vue/composition-api，然后再main.js文件中引入PiniaVuePlugin再通过vue.use进行注册再调用createPinia创建pinia实例，最后将pinia实例添加到new vue中。

(5)技术栈：
vue2的技术栈是      ： vue-cli + vue2+ vue-router3+ vuex3/4 +axios + 组件库（ui） +插件 + js
vue3的技术栈是      :    vite + vue3 + vue-router4 + pinia +axios + 组件库（plus） +插件库 + ts

vue3中添加了一个内置组件：Teleport叫瞬移组件也可以叫传送门，Suspense占位具有加载的组件

33. 项目搭建：
首先根据需求文档以及ui设计图进行项目搭建，需要多方商讨确定项目的技术栈，及项目架构，搭建前端项目的架子设定技术栈：
 vue-cli + vue2+ vue-router3+ vuex3/4 +axios + js等，要把项目所用的一些基本的插件目录（重置css）搭建好后推送到对应的代码管理仓库，拉取分支切换到自己分支里然后进行项目的 开发，搭建项目首页（自己负责的页面）：把首页进行组件的拆分，拆分成header、home（路由注册）、footer组件，hearder组件搭建的思路：通过html + css（Sass/Less/Stylus预处理器）的方式搭建页面显示对应的效果。home也是先通过htm + css的方式搭建界面，然后进行组件拆分，考虑到三级分类的展示要在多个组件使用，所以也抽取出来变成一个组件（全局组件），因为此时后台没有接口，所以我采用的是根据效果图自己定义json文件设计了一些数据，通过mockjs进行拦截生成随机数的方式进行展示，具体的步骤如下:

       首先下载mockjs进行安装，然后再对应的json文件当中定义一二三级分类部分数据，然后定义获取定义三级分类的mock接口，并且返回json数据，然后二次封装axios设置根路径和超时时间和进度条效果、请求和响应拦截器，定义获取三级分类的api接口函数，配置代理跨域信息，安装vuex，拆分首页的js模块，定义状态数据修改数据的mutation，引入api接口函数封装获取三级分类的action，在app组件中通过dispatch分发对应的action，在三级分类对应的组件中通过mapState获取三级分类的信息数据，使用三层v-for指令和route-link遍历及显示三个级别的信息数据，发现页面卡顿，调整成a标签直接显示分类数据，然后绑定事件实现路由跳转及参数传递，发现页面卡顿，通过事件委托为最外层的父级标签绑定一个点击事件，内部判断出发事件的元素   实现路由的跳转，并且从路由的信息对象中获取对应的params参数，如果有就合并query进行传递，如果没有只携带query参数  ，通过节流的方式优化鼠标在一级分类的信息，滑动事件展现高亮效果，减少事件触发效果，后台接口准备成功后直接替换mock接口。

34. 详情页中销售属性功能的实现思路
根据接口调用返回来的销售属性数组通过双层v-for遍历销售属性对象数组和属性值对象数组展示信息，然后为每个属性值绑定点击事件传入销售属性对象、属性值对象、销售属性索引，内部首先把当前的销售属性对象中属性值对象数组遍历设置选中状态为false，点击的这个属性值对象的选中状态为true。获取属性值的id以及其他属性值选中的id，使用竖线将多个属性值的id拼接形成字符串，在json格式的对象中判断拼接后的属性值id是否有对应的产品id，如果有通过路由器对象调用replace方法进行路由的跳转，如果没有就设置购物车取消高亮显示，禁用按钮点击。

35. 购物车功能实现的业务逻辑思路：
       首先在详情页为加入购物车按钮绑定点击事件，回调函数内部先调用加入购物车的api接口函数，传入商品的id，接口调用成功后进行路由跳转，并且传递商品数量同时把商品信息对象存储到sessionStorage，此时进入到加入购物车成功界面，该页面如果直接进行刷新操作，还要继续显示商品信息所以需要从缓存中读取这个数据 。
       然后点击购物车结算的按钮进行购物车路由的跳转，此时可以把缓存中商品信息清空，同时路由跳转到购物车界面，用户在没有登录的情况下依然可以看到添加到购物车的商品列表数据，采用的是临时用户id的方式把商品加入到购物车，用到了一个uuid的插件把产生的临时用户id缓存到vuex同时在请求拦截器中请求头嵌入了临时id。如果用户登录了把商品加入到购车车，进入到购物车界面后展示的是未登录和已登录添加到购物车的商品数据（后台人员已经对数据进行了合并处理）。购物车组件页面是一个路由组件采用的html + css搭建静态页面，然后调用获取购物车列表的api函数，得到购物车的数组数据，vuex内部通过计算属性计算出全选的状态、商品的总数、和总价格，组件内部通过v-for指令遍历所有的商品列表数据进行展示并获取计算属性中的数据展示全选的状态、商品的总数和总价格，每个商品都可以进行选中状态的改变，采用的是防抖的方式优化事件触发的次数，减轻服务器压力。商品数量的修改也采用了防抖或节流优化事件触发次数。单个商品的删除以及选中商品的删除都进行了弹框提示处理也是为了提升用户的体验。全选和全不选的操作也需要进行优化，点击结算按钮进行路由跳转传递订单等相关信息。

36.模态对话框组件封装
       定义组件文件搭建静态页面，定义组件中所需要的数据通过props定义组件中所需要的外部组件传入进来的数据，通过watch监视区域的ID数据进行对应城市接口的调用，以及监视外部组件传入进来的数据，组件内部需要绑定下拉框的选中事件根据区域ID的变化把获取到的省份数组信息进行遍历。------》定义一个JS文件，引入vue和组件对象，通过vue.extend方法根据组件对象产生对应的组件构造函数，创建对象内部设置init方法通过单例模式的方式创建组件对象，以及产生真实的DOM并且挂载到body标签中，需要绑定一个unmount方法从body中移出这个组件，还定义了一个clear方法负责清空组件内部的数据，也为当前组件对象通过Object.defineProperty方法绑定了确认、取消、数据对应的属性。最后为vue的原型对象添加了一个属性绑定的是一个方法，内部调用init方法，也就意味着在其他组件中通过组件实例对象调用原型上的方法组件就会产生并且在界面当中显示。

37. 登录模块
（1）先通过elementplus和sass搭建登录组件，然后进行路由组件的注册
（2）通过swagger测试接口使用ts中interface定义该接口返回值的数据类型
（3）通过枚举定义登录相关的接口地址
（4）封装登录相关的api接口函数
（5）在pinia中拆分出一个用户信息相关的模块引入登录相关的api接口函数（三个：），定义用来存储用户信息的相关状态数据，定义登录相关的action，登录组件内部先进行表单规则的定义及验证表单的操作，通过标识设置密码框是否明文为登录按钮绑定点击事件在对应的回调函数内部进行所有表单的验证，通过后取出对应的账号密码，分发登录的action传入账号密码，如果失败设置提示信息并且关闭加载效果（finally），如果登录成功通过编程式路由跳转到首页，然后进去到全局前置导航守卫，判断token信息是否存在，如果不存在判断跳转的路径是不是白名单中的地址（登录）如果是放行到登录界面，如果不是跳转到登录界面同时记录要跳转的目标路由地址，如果token存在判断要跳转的路径是不是登录界面的地址，如果是控制路由跳转到首页，如果不是判断用户信息是否存在，存在则直接放行，如果用户信息不存在在请求头中嵌入token调用获取用户信息的action（如果action中携带token调api接口失败了，可能是token过期，需要重新跳转到登录界面进行登录）：

路由鉴权：


接口调用失败则重置用户信息并且跳转到登录界面，如果接口调用成功直接放行到目标路由地址即可。

38.平台属性
       考虑到三级分类组件要在不同的组件中使用，所以抽取出来变成一个全局组件，采用en-form组件和el-select组件以及sass进行页面搭建，通过封装三级分类的pinia的一级二级三级分类、id及数组数据进行数据状态的定义，并且通过计算属性计算出一二三级分类的id及数组数据的计算，并且封装一级分类数据、2级分类数据、3级分类数据，然后在组件内部通过计算属性针对一级分类的id计算属性设置get和set，get需要获取id，set中通过设置一级分类的数据分发获取二级分类的action，下拉框组件中通过v-model绑定一级分类id通过v-for指令遍历一级分类数组数据并且绑定key，label及value属性，这样在组件加载的时候先获取一级分类数据并且展示，当选中的分类内容发生变化后通过计算属性的set方法立刻获取二级分类的数据，并且清空二级分类id、三级分类id以及三级分类数组数据，二级分类数据选中同上。在平台属性内部通过el-button、el-table搭建界面，并且在该组件内部针对三级分类的id进行监听操作，根据一二三级分类di的变化获取不同分类信息下的平台属性数据，也就是监听三级分类id调用平台属性的接口。在实现平台属性的删除操作时调用了papconfirm气泡确认框组件，并且在该组件内部绑定了一个comfirm的事件，内部调用删除平台属性的api接口函数传入id，删除操作后设置提示信息并且进行刷新操作。

前两年通过vue2框架+element-ui组件库开发xxx后台管理项目的时候也用到了气泡对话框组件，当时我印象中好像应该是2.13.0，confirm事件的写法是onConfirm，当然现在已经没有这个bug了，当时也困惑了一段事件(继续编。。。。)

修改平台属性的时候，为修改按钮绑定了点击事件，切换主界面和修改界面采用的是v-show传入指令，并且通过深拷贝的方式传入了平台属性对象信息，使用el-table组件绑定平台属性对象中的属性值对象数组进行展示，每一行的属性值都有编辑和查看模式的操作，所以使用了作用域插槽的方式进行了占位，内部使用span标签展示属性值，使用el-input组件用来编辑这一行的属性值，依然使用v-if指令用来切换span和el-input显示和隐藏，默认情况下显示的是span标签及属性值内容，为span标签绑定事件，内部设置标识为true，展示el-input标签，并且使用了nextTick方法让文本框自动获取焦点，目的是为了用户进行编辑模式的时候自动获取焦点，有一个更好的体验，文本框失去焦点后文本框隐藏，为让用户也有一个好的体验，span元素从行内元素变成行内框并且设置宽度为100%。


39. 路由鉴权的实现：
路由是一种映射关系，是地址和组件的关系，当路由注册后可以实现的是浏览器的地址栏输入地址，回车后可以看到对应的组件，为了实现路由鉴权先把最基本的登录、首页、404三种路由拆分成默认路由（静态路由、常量路由、基本路由，普通权限路由）进行路由的注册，其他的路由再次进行拆分拆分成动态路由（异步路由、高级权限路由）和任意路由（追加路由，错误信息路由），也就是只有默认路由被注册了，这样任何用户都可以看到登录界面，登录后可以看到首页及404界面。在获取用户信息的时候，先把用户信息中的用户名字标识数组存储到pinia中，然后引入路由器对象静态路由数组、动态路由数组、任意路由对象进行路由的过滤操作，也就是定义一个函数传入路由名字标识数组和动态路由数组，内部调用filter方法加递归的方式进行路由名字对比后和过滤，把过滤后的路由对象组成一个新数组，通过路由对象调用addRoute方法把过滤后的每个路由对象进行二次路由注册，并且要把任意路由进行注册，同时把所有的路由对象形成数组存储到pinia中（任意路由不要），此时用户登录成功后在浏览器的地址栏中输入地址可以看到该用户所拥有的权限对应的路由组件内部，但是这种方式用户体验不好，而且也看不到左侧菜单信息，所以在用户跳转到首页的过程中layout组件内部sideBar组件在展示的时候把pinia中存储的路由对象数组获取到并且通过v-for指令进行遍历还要绑定对应的路由对象的title属性和路由地址，最终页面显示完毕后该用户就可以看到所拥有权限对应的菜单内容，用户点击菜单就可以看到对应的组件内容，以上是路由鉴权实现的思路。作用：路由鉴权的目的是控制用户对应觉得角色可以看到哪些菜单。

40.  谈谈按钮的鉴权：
在获取用户信息的时候，把用户信息中按钮名字标识数组存储到pinia，然后通过vue的directive方法定义一个全局的指令，并且在该方法的第二个参数配置对象中，mounted的生命周期中获取pinia中已经存储的按钮名字标识数组，判断该数组中是否有使用指令的时候传入进来的标识，如果没有，通过使用这个指令的标签的父级节点调用removeChild移除这个标签，所有的组件中的操作按钮都要使用这个全局的自定义指令传入相关的标识，可以实现按钮的权限操作。作用目的：控制用户对应的角色可以看到哪些操作按钮（可以看到哪些组件中的按钮可以显示和隐藏）。

41,谈谈小程序的生命周期
（在微信小程序中声明周期分为三种：分别是应用实例的生命周期、页面的生命的周期和组件的生命周期，生命周期3-5-5，
应用实例的生命周期分为onLaunch（小程序程序实例初始化）、onShow（小程序启动或者切换到前台时执行）、onHide（代表的是小程序切换到后台时执行）

页面实例的生命周期:onLoad页面实例对象创建的时候执行（一个一面只会调用一次），onShow页面将要绘制的时候出现（页面刚要显示的时候），onReady页面第一次渲染完毕的时候执行，onHide页面隐藏的时候执行，onUnload页面卸载的时候执行，

组件的生命周期：created组件实例刚被创建的时候触发，attached组件实例进入到页面节点树的时候执行，ready组件在视图层布局完成后执行，moved组件被移动到另一个位置时执行，detached组件实例从页面中移除时执行。

42小程序中通信方案
一. 页面和页面之间通信：（1）可以使用全局唯一小程序实例，也就是在app.js文件中定义globalData全局数据，其他页面中通过getApp（）方法得到全局唯一实例对象，页面中可以使用这个数据。（2）storage：主要是为了缓存数据，最多存储10M但是也可以实现页面之间数据的传递，（3）自定义全局总线：eventBus （4）pubsub消息订阅的方式实现页面通信 （5）getCurrentPages：使用该方法获取某一个页面实例调用里面的数据进行页面的通信

二. 组件之间通信：（1）父级组件直接向子级之间以动态数据的方式传递数据，子级组件内部通过properties接收父级组件传递过来的数据，然后进行使用实现通信 （2）自定义事件：父级组件向子级组件传递自定义事件，子级组件内部通过triggerEvent（）方法分发事件及传递数据实现通信。

43.小程序登录的流程：
首页在app.js文件中的onLaunch生命周期里边判断本地缓存中是否有用户信息，如果有加载用户信息跳转到首页，如果没有调用wx.login方法得到授权码code值，然后将code码值调用后台接口发送到开发者服务器，开发者服务器内部在该接口对应的回调函数内部通过req.query.code获取code码值，然后准备开发小程序的appid以及开发小程序的密钥（appsecret），再准备code2session接口地址，（通过flyio调用方法传入地址及准备好的参数，向微信服务端发送请求获取session_key和openid数据，然后通过jsonWebToken（jwt）调用sign（）方法传入用户的相关信息数据及密钥产生token信息，可以通过md5进行二次加密，把token返回到小程序中）让后端人员调用该接口获取获取openid、session_key等相关信息产生对应的token发送给前台小程序。小程序中把获取到token缓存到storage中，然后通过wx.getUserProfile()获取用户的相关信息并进行存储，然后进行页面的跳转，在相关的页面展示用户信息。

44.原生小程序和uniApp的区别：
原生小程序只能开发小程序，里面不是直接使用html标签而是使用的组件，而uniApp是基于vue的框架，不仅可以做小程序开发还可以做webApp和混合App（一个代码多个平台运行）开发以及发布安卓或ios的应用。小程序是wx开头调用相应的api，使用的rpx像素单位，uniapp前缀是uni开头的调用相应的api，使用的是upx像素单位（现在的uniapp直接支持rpx）。uniapp框架中开发小程序的时候可以使用html代码，可以使用vue的生命周期钩子。


45.谈谈项目的优化（代码、打包、服务器开启设置）
首先可以从代码层面进行优化，比如页面中控制元素的显示和隐藏v-if、v-show，如果频繁操作显示和隐藏使用v-show。如果数据表达式比较长或者使用次数比较多可以使用computed进行缓存，如果使用了大量的数据可以使用Object.freeze进行数据的冻结，这样做可以切断数据的劫持，提升和节省内存的性能。如果遇到了不涉及与用户界面的更新操作，可以把数据绑定到this上 ，如果是一些切换操作，可以把组件使用keep-alive进行缓存。v-for遍历数据的时候要设置key值，避免v-for和v-if同时使用。需要大量数据渲染的时候可以采用分页或者虚拟长列表的方式进行优化。图片显示方面可以进行懒加载操作还可以使用路由懒加载进行优化。第三方的插件可以进行按需引入（elemetui），高频事件的触发可以使用防抖或节流，大量事件的使用可以使用事件委派进行优化等。打包工具方面也可以优化：比如配置webpack中的splitchunk进行代码分割，将组件库单独打包，也可以将vue相关的库进行单独打包，如果是vue3的项目要想解决vite首次打开页面加载过慢的问题可以配置插件（vite2.9.1之前）新版的vite内置了这些插件，但是一次加载的速度还是稍微慢了点。最后网络层面也可以进行优化，需要开启服务端的设置比如可以开启gzip进行文件的压缩设置，http版本的设置、压缩级别的设置、文件类型的设置，还可以开启浏览器的缓存机制（强缓存和协商缓存），结合webpack配置使用cdn的方式以及升级http协议为2.0。


46. 大屏渲染适配方案：
可以使用rem或者viewport适配以及scale缩放适配（scale缩放适配 主要是通过css属性根据屏幕的大小对图标进行整体的等比缩放从而达到自适应的效果，判断屏幕尺寸的比例达到页面的全屏展示内容占满显示屏，比如：当屏幕的尺寸比例刚好是16：9的时候页面沾满显示器，如果比例小于16：9页面上下留白左右沾满并上下居中显示比例保持16：9，当屏幕尺寸比例大于16：9时，页面左右留白上下沾满并居中，显示比例保持16：9，也就是先确定设计稿的大小有宽度和高度然后基于宽和高进行缩放）。

47. 大文件上传实现的思路
首先通过elementUi中的upLoad组件封装一个上传文件的组件，该组件中设置http-request自定义上传功能的钩子，内部要限制上传文件的个数及上传文件的大小，然后在该钩子中先生成文件的碎片，也就是按照指定的大小对一个大的文件循环的进行切割，使用了数组的slice方法，把切割后的每个文件形成了切片文件存储到数组中，每个文件的类型是Blob，然后通过数组map遍历的方式产生切片文件信息对象，该对象中包含切片文件和哈希值数据（包括文件名，哈希值和索引值）形成了一个切片文件的名字，通过webWorker开一个分线程把切片文件数组传入进去，分线程内部通过遍历文件，读取文件内容以及md5的方式计算每个文件的哈希值（原因：大量的计算容易导致页面卡顿），在确认每个切片文件产生信息对象的同时，还要设置进度展示，然后开始上传切片，遍历切片文件数组，然后调用接口设置请求地址上传文件，还有开启进度条，通过promise.all的方式传入切片文件数组采用一次性上传多个小文件的方式，最后通知服务器文件是否上传成功，当所有的文件都上传成功后服务器端根据切片文件的名字中的序号进行文件的合并，切片上传文件上传成功。如果采用断点续传，有两套方案：1.通过前端的缓存机制记录已经上传的切片的哈希值，这种方式有缺陷，一旦更换浏览器就无法确认哪些切片是上传成功的。2.在服务端保存已经上传的切片文件的哈希值，浏览器中每次上传文件之前先向服务器发送请求，获取已上传的哈希值进行判断，过滤掉相同的，把不一样的进行上传，秒传实现，文件上传之前把当前文件对应的哈希值发送到服务端，服务端进行大文件的哈希值对比，如果一样直接响应给客户端提示上传成功。断点续传的前提的是文件做了切片处理。

48 .针对word excel pdf处理所用到插件：
使用了一个html2canvas的插件和jsPDF插件，前者是js库可以将html渲染为canvas元素，也就是将页面中的图片、文本、svg都可以转换为像素图像就可以在页面上进行内容的截图生成pdf图片进行预览，后者是一个客户端用来生成pdf文档的js库，可以用来创建和下载pdf文档，不需要使用服务器或第三方服务，该插件功能很强大，有很多扩展性插件可以添加水印、导入导出、生成二维码和条形码等操作。

excel导入导出依赖js-xlsx还依赖file-saver和script-loader

word导入导出需要的插件：（
npm install file-saver
npm install docxtemplater-image-module-free
npm install docxtemplater
npm install pizzip
npm install jszip-utils          ）


49. 谈谈react和vue的区别：
无论是react还是vue都是单向数据流，但是vue中有双向数据绑定，都有虚拟dom，react中每当应用状态发生改变过时全部的子级组件会重新渲染，也可以通过PureComponent/shouldComponentUpdate 这个生命周期方法来进行控制，但是vue中每个组件都有对应的依赖关系，不需要重新渲染这个组件树，这种行为是默认的，关于组件化vue提供了单文件组件的方式，里面的包含了html、css和js类似于html语法，而react是通过jsx语法来定义组件，二者（react和vue3）都支持ts和tsx语法，更新用户界面的方式不一样，vue中的数据是响应式的，数据更新界面也会更新，而react需要使用setState方法或者useState提供的函数来触发用户界面更新，react不是响应式的，构建工具都有各自的脚手架，vue使用的是vue-cli，react使用的creat-react-app，而vite都可以创键两个框架。vue中跨平台使用的是veex，react使用的native，vue强调是数据的可变性，react强调的是不可变性，也就是不改变原数据，每次产生一个新的数据，然后前后进行对比，然后界面进行更新，react中组件通信可以使用props方式组件通信，也可以使用xxx实现子父通信。xxxx
还可以使用context实现祖孙组件通信，还有redux和modx实现任意组件的通信。
redux其他框架中也可以使用，现在和react实现了深度绑定，是一种集中式的方案，由store（用来管理状态数据）、Actions（用来返回一个action对象函数模块）和reduces（根据之前的状态和action对象来计算生成新的状态函数模块）。流程：组件中通过dispatch传入action对象触发reduces，内部根据action的tap使用switchkeys进行对比和计算，修改状态数据，手动更新组件。

mobx：这种方式是将数据保存在分散的多个store中使用observable保存数据，数据是响应式的当数据发生变化后自动处理用户界面的更新，redux使用的不可变状态也就是状态是只读的不能直接修改，而是直接返回一个新的状态。mobx中的状态是可变的可以直接进行修改。流程：通过class的方式来定义内部的数据是状态数，方式是用来更新状态数据，构造器中需要使用makeAutoObservable（）方法中传入，让实例上的方法变成响应式的。组件内部可以通过这个类的实例调用方法修改数据也可以直接修改数据，最终使用observer高阶组件对当前组件进行包裹用来监听数据变化，一旦变化就会自动的重新渲染组件。

react中常见的Hook：
一个是useState让函数组件定义并维护状态数据，useEffect让函数组件使用生命周期，useCallback缓存函数不必重新生成一个新的函数，usememo缓存计算结果值。

react中定义组件有两种方式：类组件和函数组件，类组件需要继承class，函数组件不需要，类组件可以访问生命周期钩子函数组件不能，类组件中可以使用this函数组件不可以，类组件可以定义和维护state，函数组件不能，函数组件想要做这些事需要使用hook函数。

react中类组件周期生命周期：
react15：
初始阶段componentDidMount() {}，
更新阶段shouldComponentUpdate() {}，
卸载阶段：componentWillUnmount() {}，
react16：
componentDidMount() {}: 用来发送请求，设置定时器，绑定事件等任务；
shouldComponentUpdate() {}: 性能优化，减少 render 次数；
componentWillUnmount() {}: 清除定时器，解绑事件等收尾工作

react中函数组件生命周期：
通常使用 React.useEffect 来完成

扩展：useEffect 依赖为空数组与 componentDidMount 区别在 render 执行之后，componentDidMount 会执行，如果在这个生命周期中再一次 setState ，会导致再次 render ，但是浏览器只会渲染第二次 render 返回的值，这样可以避免闪屏。
但是 useEffect 是在真实的 DOM 渲染之后才会去执行，这会造成两次 render ，这两次可能都会渲染出来，可能会闪屏。
实际上 useLayoutEffect 会更接近 componentDidMount 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。
扩展：useEffect 和 useLayoutEffect 区别对于 React 的函数组件来说，其更新过程大致分为以下步骤：

1. 因为某个事件回调导致 state 发生变化。
2. React 内部更新 state 变量。
3. React 处理更新组件 render 方法中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。
4. 将更新过后的 DOM 数据绘制到浏览器中。
5. 用户看到新的页面。
useEffect 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。
useLayoutEffect 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行

react中路由：
需要使用createBrowserRouter创建路由对象，设置路由的配置选项：path和element的关系，通过RouterProvider组件来渲染路由，路由配置项中children设置子路由，子路由默认是不渲染的，需要通过父路由加载outlet组件才会渲染子路由，react中也有生名式路由和编程式路由，使用的是link和Navlink，navlink激活的时候有高亮。编程式导航使用的是useNavigate 和 redirect，路由的参数有query，params，state，但是state地址栏不可见重新加载页面参数会丢失，可以使用Suspense组件和 lazy函数实现路由懒加载。



50. diff算法的理解：
目的：更快的渲染dom树，其原理就是对比新旧dom树中的节点及key的比较，具体流程如下：
在更新操作的时候最终会调用updateChildren方法内部首先定义8个变量分别是：旧前指针、旧前节点、旧后指针、旧后节点、新前指针、新前节点、新后指针、新后节点。内部首先通过循环的方式判断旧前指针是否小于等于旧后指针，并且新前指针是否小于等于新后指针，进行节点和key的对比。首先判断旧前节点和旧后节点是否有意义，有意义才做比较。先判断旧前节点和新前节点是否一致如果一致进一步的判断子节点，并且移动移动旧前指针加一，新前指针加一。然后再判断旧后节点和新后节点是否一致，如果是依然要对内部的子节点进一步比较，同时旧后指针和新后指针同时向前移动一位继续判断旧前节点和新后节点是否一致，如果一致把旧前节点插入到新后节点对应的索引位置的旧后节点的后面，同时移动旧前指针到下一位，新后指针向前一位，再继续比较旧后节点和新前节点是否一致，如果一致把旧后节点移动到新前节点对应的索引位置对应的旧前节点的前面。如果节点都不一样那就比较key，首先要判断旧key存不存在，然后判断新节点树中的这个key在旧树中所有的key中在不在，如果不在就删除旧树中当前正在做对比的节点内容，创建新的节点内容，插入到这个位置。以上就是diff算法的流程，采用的是两侧向中间双向对比的算法来实现dom更新计算。


51.谈谈垃圾回收机制理解
首先在浏览器中有一个专门的线程每隔很短的时间就会运行一次判断一个对象是否是垃圾对象，如果是就清除其内存数据，并标记内存是空闲状态，这种机制叫做垃圾回收机制，清理垃圾对象的工具叫做垃圾回收器。如果这个对象为null，一个数据在内存中可以被访问可以使用表示是一个可用数据也叫做可达性，如果是垃圾对象数据不可用叫做不可达。垃圾回收机制中有两种算法：引入计数法（判断这个对象的引用数量是否为零，如果为零表示可以清理，这种算法有一个缺点，出现循环引用会导致无法清理，出现内存泄漏，如果数量比较多会导致内存溢出）和标记清除法（判断该对象是否可用，或者说能不能获取到这个对象，如果获取不到，表示该对象是垃圾对象可以被清理）。垃圾回收机制其原理就是定期找出不在用到的内存，然后将其释放，不是实时找出无用内存并释放，其原因是实时开销太大。

标签清除法的流程：垃圾回收器在运行的时候为内存中的变量添加一个标记，如果是垃圾对象就标记为0，否则标记为1，然后从各个对象开始遍历，清理所有标记为0的垃圾对象，销毁并且回收占用的内存空间，然后再把所有内存中的对象标记为0，等待下一轮的回收（回收的过程当中正在占用或使用的标记为1），这种方式的优点实现简单，为非就是打不打标记两种情况，而且采用0和1二进制的方式，简单。缺点：清除之后剩余的内存位置不变，导致内存控件不连续，出现了内存碎片，如果再有新对象会出现内存分配问题，为了存储新对象需要遍历所有的内存空间，找到大于等于新对象大小的块返回，或者是遍历整个空闲列表，找到大于等于新对象的最小块，或者是找到最大的块切成两部分，一部分和新对像大小一样，这种方式会产生很多小块，再次出现内存碎片化，如果考虑到速度和效率，第一个方式是比较合理的，所以标记清除法是在清理后新对象分配的时候出现了内存碎片化和分配速度慢两个问题，所以可以使用标记整理算法（mark-compact）有效的解决这个问题，其实就是在标记结束后将活着的对象所占用的内存移动到一端，需要清理的对象占用的内存移动到另一端。后来v8引擎增加了回收策略采用分代式垃圾回收，也就是把大、老、长的对象放到老生代区域，小、新、短的对象放到新生代区域。新生代的容量为1-8M，新生代区域多次回收存活下来的会放到老生代区域，并且新生代对象是通过scavenge算法进行垃圾回收，cheney复制的算法将堆内存分为使用区和空闲区，也就是新对象放在使用区，快满的时候就执行一次垃圾清理操作，然后对存活的对象标记，干掉垃圾对象，转换为空闲区，然后空闲区变成使用区吗，如果一个对象在新生代区域中存活的时间比较长，或者一个对象占用或超过空闲区的四分之一后直接扔到老生代区域，为了不影响使用，老生代区域直接干掉垃圾对象，分代的目的是为了快速清理内存提升效率，当然v8引擎后期采用了定性回收机制，也就是js是单线程，垃圾回收如果开始会素塞进行，回收结束后js才继续执行，叫全停顿页面出现卡顿，所以v8使用，也就是用多个垃圾回收器一起回收，缩短时间。多个垃圾回收器同时进行回收，只回收一点，然后切换js反复进行，后来也增加了三色标记法和惰性清理（可以先不清理让js执行，抽空再清理）。


52. 强制缓存和协商缓存：
       首先无论是强制缓存或协商缓存都是浏览器的缓存方案，就是对之前请求过的文件进行缓存等到下一次访问的时候，重复使用，节省带宽提升速率降低服务器压力。

（1）强缓存：指的是浏览器不会向服务器发送请求直接从本地的内存和硬盘中读取缓存文件，响应状态码为200不访问服务器优先从内存中读取，再从硬盘中读取，最后才是请求网络资源。强缓存是由服务器设置的，浏览器向服务器发送请求（第一次），服务器返回资源的时候会在响应头嵌入字段expires（http1.0协议的强制缓存方案）和cache-control（http1.1的强制缓存方案），如果同时设置两个字段cache-control生效，因为他的权限更高，expires存的是一个时间戳，cache-control中可以通过maxage设置缓存时间单位是秒，public任何人都可以访问的资源，private只能个人访问，no-cache强制客户端直接向服务端发送请求，no-store停止一切缓存。

（2）协商缓存：浏览器必须向服务器发送请求，由服务器判断请求的资源是否变化来决定是否读取缓存，响应码304走缓存，200不走缓存，协商缓存的流程浏览器向服务器发请求的时候，服务器会在响应头中嵌入Etag / Last-Modified，浏览器在接收资源的时候会保存这两个字段，如果刷新或重新请求资源时会在请求头中携带 If-None-Match（它的值就是之前保存的 Etag） 和 If-Modified-Since（它的值就是之前保存的 Last-Modified）两个字段发送给服务器，服务器会判断  If-None-Match 和 If-Modified-Since 和服务器保存的 Etag 和 Last-Modified 字段是否一致，如果一致返回304读缓存，如果不一致返回新资源和新的 Etag 和 Last-Modified 字段响应码200，Etag 由文件索引节大小、修改时间计算哈希值， Last-Modified 文件最后修改的时间。

（3）流程：当浏览器打开页面向服务器发送http请求的时候，先判断是否命中强制缓存，如果没有直接向服务器请求新资源，如果有强制缓存要判断是否过期，如果没有过期直接从内存和硬盘中读取不向服务器发送请求，如果过期判断是否有协商缓存依据就是有没有Etag 和 Last-Modified ，如果有向服务器发送请求，请求头中嵌入 If-None-Match 和 If-Modified-Since ，有服务器判断是否有变化，没变化返回304，变化了返回新资源，返回200，携带新的Etag 和 Last-Modified 字段，如果没有协商缓存访问新资源。	

53.  重排重绘

54.nextTick：
首先nextTick方法的作用：在下载dom更新后执行延迟回调，应该是在数据更新之后立刻调用这个方法获取更新后的dom，当这个方法执行的时候会传入回调，内部有一个callback的数组用来存储传入的回调，以及更新界面的回调。如果在更新数据后使用nextTick方法，内部会先把更新界面watch对象对应的回调先加入到callback中，通过定时器的方式把手动传入的回调变成宏任务，这样就做到了先更新数据再更新界面再执行传入的宏任务回调，如果是先调用nextTick方法后更新数据，那么内部callback数组中手动传入的回调会通过promise或者mutationObserver变成微任务，更新界面的watcher对象对应的回调后执行，那么这个执行流程就是更新数据执行微任务再更新界面。它的应用：















工厂函数/工厂模式：
for-in 和 for-of：
http：
